#!/usr/bin/env python3

# System
import os
import re
import sys
import json
import time
import email
import imaplib
import getpass
import logging
import datetime
import traceback

# Project
import termchars
try:
    import config
    config.default_profile
    config.profiles
    config.SUBJECT_PATTERNS
    config.SENDER_PATTERNS
    config.RECEIVERS_PATTERNS
except ModuleNotFoundError:
    print("Copy config.py.sample to config.py and edit it!")
    sys.exit(1)
except AttributeError as e:
    print("Check your config.py")
    print(e)
    sys.exit(1)

# We use root logger
logConfig = {
    "format": "%(asctime)s %(levelname)s %(message)s",
    "datefmt": "%Y-%m-%d %H:%M:%S",
}

if hasattr(config, "log"):
    logging.basicConfig(**config.log)
else:
    logging.basicConfig(**logConfig)

logger = logging.getLogger()
logger.setLevel(logging.ERROR)

def getpassword(profile, account):
    if sys.platform != "darwin":
        return None

    def decode_hex(s):
        s = eval('"' + re.sub(r"(..)", r"\x\1", s) + '"')
        if "" in s: s = s[:s.index("")]
        return s

    cmd = ' '.join([
        "/usr/bin/security",
        " find-generic-password",
        "-g -s '%s' -a '%s'" % (profile, account),
        "2>&1 >/dev/null"
    ])
    p = os.popen(cmd)
    s = p.read()
    p.close()
    m = re.match(r"password: (?:0x([0-9A-F]+)\s*)?\"(.*)\"$", s)
    if m:
        hexform, stringform = m.groups()
        if hexform:
            return decode_hex(hexform)
        else:
            return stringform


def setpassword(profile, account, password):
    if sys.platform != "darwin":
        return None

    cmd = 'security add-generic-password -U -a %s -s %s -p %s' % (account, profile, password)
    p = os.popen(cmd)
    s = p.read()
    p.close()

def shall_we_delete(subject, senders, receivers):
    for token in config.SUBJECT_PATTERNS:
        if subject.find(token) != -1:
            return True
    for token in config.SENDER_PATTERNS:
        for sender in senders:
            if sender.find(token) != -1:
                return True
    for token in config.RECEIVERS_PATTERNS:
        for receiver in receivers:
            if receiver.find(token) != -1:
                return True
    return False

def get_header(mail, header):
    try:
        if mail is None:
            return ""

        content = mail.get(header) or ""

        def _decode(arg):
            value, encoding = arg
            if type(value) == str:
                return value

            if value is None:
                return ''

            if encoding is None:
                return value.decode()

            try:
                return value.decode(encoding)
            except LookupError:
                return value.decode()

        return ' '.join(map(_decode, email.header.decode_header(content)))

    except Exception as e:
        traceback.print_exc()
        print( f"fetching {header} email {mail}" )
        return ""

def get_emails(mail, header):
    value = mail.get(header)
    value = str(value)
    if value is None:
        return []
    try:
        return re.findall(r'''([a-zA-Z0-9._+-]+@[a-zA-Z0-9.-]+)''', value)
    except:
        raise

def prepare_cache_dir(host, user):
    if user.find("@") != -1:
        dirname = f"mailbox/{user}"
    else:
        dirname = f"mailbox/{user}@{host}"
    os.makedirs(dirname, exist_ok=True)

def search_mails(imapclient, since):
    #typ, data = imapclient.search(None, f'(SINCE "{since}")')
    typ, data = imapclient.uid("SEARCH", 'ALL')
    mailuids = list( map(lambda mailuid: mailuid.decode(), data[0].split()))
    logger.debug(f"MAILDS: " + ", ".join(mailuids))
    return mailuids

def fetch_mail(imapclient, host, user, mailuid):
    try:
        filename = mailuid + '.eml'
        if user.find("@") != -1:
            filename = f"mailbox/{user}/{filename}"
        else:
            filename = f"mailbox/{user}@{host}/{filename}"
        content = open(filename, "rb").read()
    except:
        typ, data = imapclient.uid("FETCH", mailuid, 'BODY.PEEK[HEADER]')
        content = data[0][1]
        open(filename, "wb").write(content)

    mail = email.message_from_bytes(content)
    return mail

def list_mailbox(imapclient):
    l = imapclient.list()
    for ll in l[1]:
        print(ll.replace(b'&',b'+').decode('utf-7'))

def delete_mail(imapclient, mailuid):
    try:
        imapclient.uid("STORE", mailuid, "+FLAGS", '''\Deleted''')
    except imaplib.IMAP4.error as e:
        logger.error(e.args[0])

# Fri, 16 Sep 2022 05:57:25 UTC
# Mon, 12 Oct 2020 01:54:44 +0000 (GMT-00:00)
# 4 Oct 2022 13:53:56 +0900(KST)
def normalize_date(date):
    try:
        tzinfo = datetime.datetime.strptime(config.timezone, "%z").tzinfo
    except:
        tzinfo = None
    for fmt in [
        "%d %b %Y %H:%M:%S %z",
    ]:
        # 맨 뒤의 English Timezone (ex; (KST)) 제거
        org_date = date
        date = re.sub(r'.*?(\d\d?\s+[A-Za-z]{3}\s+\d{4}\s+\d\d:\d\d:\d\d\s+([A-Z]{3,4}|[+-]\d\d\d\d)).*', r'\1', date)
        date = date.replace("GMT", "+0000")
        date = date.replace("UTC", "+0000")
        try:
            date = datetime.datetime.strptime(date, fmt)
            if tzinfo is not None:
                date = date.astimezone(tzinfo)
            date = date.strftime("%Y-%m-%d %H:%M:%S")
            return date
        except ValueError:
            #print( f'{fmt},[{date}],[{org_date}]' )
            pass
    return date

def delete_at_once(profile, host, user, passwd, mailbox, dryrun, since, imapclient = None):

    if imapclient is None:
        imapclient = imaplib.IMAP4_SSL(host)
        imapclient.login(user, passwd)

    result = imapclient.select(mailbox.encode('utf-7').replace(b'+', b'&'))
    if result[0] != "OK":
        print(result[1][0].decode())
        return True

    prepare_cache_dir(host, user)

    count = 0
    mailuids = search_mails(imapclient, since)
    for mailuid in mailuids:
        count += 1
        try:
            mail = fetch_mail(imapclient, host, user, mailuid)
            subject = get_header(mail, "Subject")
            date = get_header(mail, "Date")
            senders = get_emails(mail, "From")
            receivers = get_emails(mail, "To")
            ccs = get_emails(mail, "Cc")
            replytos = get_emails(mail, "Reply-To")
            sender = ",".join(senders)
            receiver = ",".join(receivers + ccs)
            date2 = date
            date = normalize_date(date)

            subject = subject.replace("\n", "").replace("\r", "")
            subject2 = termchars.substr(subject, 0, 70, fill=True)
            print(f"({profile}:{count}) {subject2} {date} {sender:40.40} {receiver:40.40}", end="")
            if shall_we_delete(subject, senders, receivers + ccs + replytos):
                print(f"  ---> DELETE")
                if not dryrun:
                    delete_mail(imapclient, mailuid)
            else:
                print(f"  ---> KEEP")
        except imaplib.IMAP4.error as e:
            logger.error(f"Error in treating mailuid {mailuid}")
            logger.error(f"Error: {e.args[0]}")
            imapclient.print_log()
            imapclient.close()
            return False
        except:
            logger.error(f"Error in treating mailuid {mailuid}")
            raise

    return True

def main(profile, dryrun=True, mailbox_list=False, **kwargs):
    profile_conf = config.profiles.get(profile)
    if profile_conf is None:
        logger.error("Invalid profile")
        return

    if 'mailbox' not in profile_conf:
        print("No mailbox specified, list mail boxes")
        mailbox_list = True

    passwd = getpassword(profile_conf["host"], profile_conf["user"])
    if passwd is not None:
        ssl_context = imaplib.ssl._create_stdlib_context()
        ssl_context.set_ciphers('DEFAULT@SECLEVEL=1')
        imapclient = None
        trycount = 2
        while imapclient is None and trycount > 0:
            try:
                imapclient = imaplib.IMAP4_SSL(profile_conf["host"], ssl_context=ssl_context)
            except imaplib.ssl.SSLError:
                logger.debug(f"Connect: " + traceback.format_exc())
            trycount -= 1
        if imapclient is None:
            print(f"Can't establish connection to {profile_conf['host']}")
            return
        print(f"* Connected to {profile_conf['host']}")
        try:
            result = imapclient.login(profile_conf["user"], passwd)
        except imaplib.IMAP4.error as e:
            print(e.args[0].decode())
            passwd = None

    while not passwd:
        passwd = getpass.getpass(f"Password for {profile_conf['user']}: ")
        imapclient = imaplib.IMAP4_SSL(profile_conf["host"])
        try:
            result = imapclient.login(profile_conf["user"], passwd)
            if result[0] == 'OK':
                setpassword(profile_conf["host"], profile_conf["user"], passwd)
                break
        except imaplib.IMAP4.error as e:
            logger.error(e.args[0].decode())
            passwd = None
    profile_conf["passwd"] = passwd

    if mailbox_list:
        list_mailbox(imapclient)
        return

    since = (datetime.datetime.now() - datetime.timedelta(days=7)).strftime("%d-%b-%Y")
    while True:
        if delete_at_once(profile, dryrun=dryrun, since=since, imapclient=imapclient, **profile_conf):
            break
        imapclient = None

try:
    dryrun = True
    profile = config.default_profile
    profiles = []
    for arg in sys.argv:
        if arg == "go":
            dryrun = False
        elif arg == "debug":
            logger.setLevel(logging.DEBUG)
            imaplib.Debug = 4
        elif arg == "list":
            mailbox_list = True
        elif arg in config.profiles:
            profiles.append(arg)

    if len(profiles) == 0:
        profiles.append(profile)

    while len(profiles):
        profile = profiles.pop(0)
        main(**locals())
        if len(profiles):
            time.sleep(1)
    if dryrun:
        logger.error("")
        logger.error("If you want to delete, pass 'go' argument")
        logger.error(f"   {' '.join(sys.argv)} go")
        logger.error("")
except KeyboardInterrupt:
    logger.error("\nOk, quit.")
